package org.firstinspires.ftc.teamcode.Sensors;
import android.util.Log;

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DeviceInterfaceModule;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.navx.AHRSProtocol;
import org.firstinspires.ftc.teamcode.navx.ftc.AHRS;
import org.firstinspires.ftc.teamcode.navx.ftc.navXPIDController;


public class navxIMU {
    DcMotor dc;

    private String startDate;
    private AHRS navx_device;

    private double TARGET_ANGLE_DEGREES = 90.0;
    private double TOLERANCE_DEGREES = 2.0;


    private final double MIN_MOTOR_OUTPUT_VALUE = -1.0;
    private final double MAX_MOTOR_OUTPUT_VALUE = 1.0;
    private final double YAW_PID_P = 0.005;
    private final double YAW_PID_I = 0.0;
    private final double YAW_PID_D = 0.0;

    private double normalDriveSpeed = 0.5;

    private ElapsedTime runtime;

    int driveTimeOut;

    private navXPIDController yawPIDController;

    //TODO do this properly
    private int NAVX_DIM_I2C_PORT = 1;

    int DEVICE_TIMEOUT_MS = 500;

    enum states {
        CALIBRATING,
        CALIBRATED,
        READY,
        MOVING,
        ROTATING,
        STRAIGHTDRIVING,

        //TODO decide states
    };

    public navxIMU(DeviceInterfaceModule dim){
        navx_device = AHRS.getInstance(dim, NAVX_DIM_I2C_PORT, AHRS.DeviceDataType.kProcessedData);

    }

    public void close() {
        navx_device.close();
    }

    /**
     * Middle methods for getting various angular bearings
     */

    public float getPitch() {
        return navx_device.getPitch();
    }

    /**
     * Returns the current roll value (in degrees, from -180 to 180)
     * reported by the sensor.  Roll is a measure of rotation around
     * the X Axis.
     * @return The current roll value in degrees (-180 to 180).
     */
    public float getRoll() {
        return navx_device.getRoll();
    }

    /**
     * Returns the current yaw value (in degrees, from -180 to 180)
     * reported by the sensor.  Yaw is a measure of rotation around
     * the Z Axis (which is perpendicular to the earth).
     *<p>
     * Note that the returned yaw value will be offset by a user-specified
     * offset value; this user-specified offset value is set by
     * invoking the zeroYaw() method.
     * @return The current yaw value in degrees (-180 to 180).
     */
    public float getYaw() {
        return navx_device.getYaw();
    }

    /**
     * Returns the current tilt-compensated compass heading
     * value (in degrees, from 0 to 360) reported by the sensor.
     *<p>
     * Note that this value is sensed by a magnetometer,
     * which can be affected by nearby magnetic fields (e.g., the
     * magnetic fields generated by nearby motors).
     *<p>
     * Before using this value, ensure that (a) the magnetometer
     * has been calibrated and (b) that a magnetic disturbance is
     * not taking place at the instant when the compass heading
     * was generated.
     * @return The current tilt-compensated compass heading, in degrees (0-360).
     */
    public float getCompassHeading() {
        return navx_device.getCompassHeading();
    }

    /**
     * Sets the user-specified yaw offset to the current
     * yaw value reported by the sensor.
     *<p>
     * This user-specified yaw offset is automatically
     * subtracted from subsequent yaw values reported by
     * the getYaw() method.
     */
    public void zeroYaw() {
        navx_device.zeroYaw();
    }

    /**
     * Returns true if the sensor is currently performing automatic
     * gyro/accelerometer calibration.  Automatic calibration occurs
     * when the sensor is initially powered on, during which time the
     * sensor should be held still, with the Z-axis pointing up
     * (perpendicular to the earth).
     *<p>
     * NOTE:  During this automatic calibration, the yaw, pitch and roll
     * values returned may not be accurate.
     *<p>
     * Once calibration is complete, the sensor will automatically remove
     * an internal yaw offset value from all reported values.
     *<p>
     * @return Returns true if the sensor is currently automatically
     * calibrating the gyro and accelerometer sensors.
     */

    public boolean isCalibrating() {
        return navx_device.isCalibrating();
    }

    /**
     * Indicates whether the sensor is currently connected
     * to the host computer.  A connection is considered established
     * whenever communication with the sensor has occurred recently.
     *<p>
     * @return Returns true if a valid update has been recently received
     * from the sensor.
     */

    public boolean isConnected() {
        return navx_device.isConnected();
    }


    /**
     * All the Middle methods for linear acceleration
     */
    /**
     * Returns the current linear acceleration in the X-axis (in G).
     *<p>
     * World linear acceleration refers to raw acceleration data, which
     * has had the gravity component removed, and which has been rotated to
     * the same reference frame as the current yaw value.  The resulting
     * value represents the current acceleration in the x-axis of the
     * body (e.g., the robot) on which the sensor is mounted.
     *<p>
     * @return Current world linear acceleration in the X-axis (in G).
     */
    public float getWorldLinearAccelX()
    {
        return navx_device.getWorldLinearAccelX();
    }

    /**
     * Returns the current linear acceleration in the Y-axis (in G).
     *<p>
     * World linear acceleration refers to raw acceleration data, which
     * has had the gravity component removed, and which has been rotated to
     * the same reference frame as the current yaw value.  The resulting
     * value represents the current acceleration in the Y-axis of the
     * body (e.g., the robot) on which the sensor is mounted.
     *<p>
     * @return Current world linear acceleration in the Y-axis (in G).
     */
    public float getWorldLinearAccelY()
    {
        return navx_device.getWorldLinearAccelY();
    }

    /**
     * Returns the current linear acceleration in the Z-axis (in G).
     *<p>
     * World linear acceleration refers to raw acceleration data, which
     * has had the gravity component removed, and which has been rotated to
     * the same reference frame as the current yaw value.  The resulting
     * value represents the current acceleration in the Z-axis of the
     * body (e.g., the robot) on which the sensor is mounted.
     *<p>
     * @return Current world linear acceleration in the Z-axis (in G).
     */
    public float getWorldLinearAccelZ()
    {
        return navx_device.getWorldLinearAccelZ();
    }

    /**
     * Middle methods for various states of IMU
     */

    /**
     * Indicates if the sensor is currently detecting motion,
     * based upon the X and Y-axis world linear acceleration values.
     * If the sum of the absolute values of the X and Y axis exceed
     * a "motion threshold", the motion state is indicated.
     *<p>
     * @return Returns true if the sensor is currently detecting motion.
     */
    public boolean isMoving()
    {
        return navx_device.isMoving();
    }

    /**
     * Indicates if the sensor is currently detecting yaw rotation,
     * based upon whether the change in yaw over the last second
     * exceeds the "Rotation Threshold."
     *<p>
     * Yaw Rotation can occur either when the sensor is rotating, or
     * when the sensor is not rotating AND the current gyro calibration
     * is insufficiently calibrated to yield the standard yaw drift rate.
     *<p>
     * @return Returns true if the sensor is currently detecting motion.
     */
    public boolean isRotating()
    {
        return navx_device.isRotating();
    }

    public void setUpStraightDrivePID() {
            /* Create a PID Controller which uses the Yaw Angle as input. */
        yawPIDController = new navXPIDController( navx_device, navXPIDController.navXTimestampedDataSource.YAW);

        /* Configure the PID controller */
        yawPIDController.setSetpoint(TARGET_ANGLE_DEGREES);
        yawPIDController.setContinuous(true);
        yawPIDController.setOutputRange(MIN_MOTOR_OUTPUT_VALUE, MAX_MOTOR_OUTPUT_VALUE);
        yawPIDController.setTolerance(navXPIDController.ToleranceType.ABSOLUTE, TOLERANCE_DEGREES);
        yawPIDController.setPID(YAW_PID_P, YAW_PID_I, YAW_PID_D);
        yawPIDController.enable(true);
    }

    public double[] startDriveStraight(int TIMEOUT) throws InterruptedException {
        navx_device.zeroYaw();

        this.driveTimeOut = TIMEOUT;

        this.runtime = new ElapsedTime();

        return checkDriveStraight();

    }

    public double[] checkDriveStraight() throws InterruptedException{
        navXPIDController.PIDResult yawPIDResult = new navXPIDController.PIDResult();
        if ( this.runtime.time() < this.driveTimeOut ) {
            if ( yawPIDController.waitForNewUpdate(yawPIDResult, DEVICE_TIMEOUT_MS ) ) {
                if ( yawPIDResult.isOnTarget() ) {
                    return new double[] {normalDriveSpeed, normalDriveSpeed};
                } else {
                    double output = yawPIDResult.getOutput();
                    if ( output < 0 ) {
                        /* Rotate Left */
                        return new double[] {normalDriveSpeed - output, normalDriveSpeed + output};
                    } else {
                        /* Rotate Right */
                        return new double[] {normalDriveSpeed + output, normalDriveSpeed - output};
                    }
                }
            } else {
			    /* A timeout occurred */
                Log.w("navXRotateToAnglePIDOp", "Yaw PID waitForNewUpdate() TIMEOUT.");
            }
        }
        return new double[] {0,0};
    }

    //TODO more complex methods for things like rotations
    //TODO more complex methods for things like perfect turns
    //TODO more complex methods for things like field oriented drive

    public double[] joystickAngleAdjust() {
//        double rcw = pJoystick->GetTwist();
//        double forwrd = pJoystick->GetY() * -1; /* Invert stick Y axis */
//        double strafe = pJoystick->GetX();
//
//        float pi = 3.1415926;
//
//        /* Adjust Joystick X/Y inputs by navX MXP yaw angle */
//
//        double gyro_degrees = ahrs->GetYaw();
//        float gyro_radians = gyro_degrees * pi/180;
//        float temp = forwrd * cos(gyro_radians) +
//                strafe * sin(gyro_radians);
//        strafe = -forwrd * sin(gyro_radians) +
//                strafe * cos(gyro_radians);
//        fwd = temp;

        /* At this point, Joystick X/Y (strafe/forwrd) vectors have been */
        /* rotated by the gyro angle, and can be sent to drive system */

        return new double[] {0,0};
    }

}









